!SFX_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!SFX_LIC This is part of the SURFEX software governed by the CeCILL-C licence
!SFX_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!SFX_LIC for details. version 1.
!     #########
      SUBROUTINE INIT_OUTPUT_OL_n (YSC)
!     ######################
!
!!****  *INIT_OUTPUT_OL* Keep in memory the netcdf ID of the output files
!!
!!    PURPOSE
!!    -------
!
!!
!!**  IMPLICIT ARGUMENTS
!!    ------------------
!!      None 
!!
!!    REFERENCE
!!    ---------
!!
!!    AUTHOR
!!    ------
!!      F. Habets   *Meteo France*
!!
!!    MODIFICATIONS
!!    -------------
!!      modified 05/04 by P. LeMoigne *Meteo France*
!!      modified 06/10 by S. Faroux *Meteo France*
!!=================================================================
!
!*       0.   DECLARATIONS
!             ------------
!
USE MODD_SURFEX_n, ONLY : SURFEX_t
!
USE MODD_SURFEX_MPI, ONLY : NRANK, NPIO, NPROC, NCOMM, NSIZE, NINDEX, NSIZE_TASK, LSFX_MPI
!
USE MODI_INIT_OUTFN_FLAKE_n
USE MODI_INIT_OUTFN_ISBA_n
USE MODI_INIT_OUTFN_SEA_n
USE MODI_INIT_OUTFN_SURF_ATM_n
USE MODI_INIT_OUTFN_TEB_n
USE MODI_INIT_OUTFN_WATER_n
!
USE MODI_OL_FIND_FILE_READ
USE MODI_READ_SURF
USE MODN_IO_OFFLINE,  ONLY : LWRITE_TOPO
!
USE MODD_SURFEX_MPI, ONLY : WLOG_MPI
!
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK, JPHOOK
!
IMPLICIT NONE
!
#ifdef SFX_MPI
INCLUDE "mpif.h"
#endif
!
TYPE(SURFEX_t), INTENT(INOUT) :: YSC
!
!
INTEGER           :: IRET
INTEGER           :: ILUOUT
REAL(KIND=JPHOOK)  :: ZHOOK_HANDLE
REAL, DIMENSION(:),ALLOCATABLE :: ZZS1D_FULL !orography of total domain
REAL, DIMENSION(:),ALLOCATABLE :: ZSSO_DIR_FULL !orography of total domain
REAL, DIMENSION(:),ALLOCATABLE :: ZSSO_SLOPE_FULL !orography of total domain
INTEGER, DIMENSION(:),ALLOCATABLE :: IMASSIFNUMBER_LOC !orography of local domain
INTEGER, DIMENSION(:),ALLOCATABLE :: IMASSIFNUMBER_FULL !orography of total domain
INTEGER, DIMENSION(:), ALLOCATABLE :: IDISPLS, IDISPLS_INT
INTEGER :: IPOS, IRANK, INEXTRANK, IFILE_ID, INFOMPI, JPROC, JRET
LOGICAL :: GMASSIF
!------------------------------------------------------------------------------ 
IF (LHOOK) CALL DR_HOOK('INIT_OUTPUT_OL_N',0,ZHOOK_HANDLE)
!
ILUOUT = 0
!
IF (LWRITE_TOPO) THEN
    ALLOCATE(ZZS1D_FULL(YSC%U%NDIM_FULL))
    ALLOCATE(ZSSO_DIR_FULL(YSC%U%NDIM_FULL))
    ALLOCATE(ZSSO_SLOPE_FULL(YSC%U%NDIM_FULL))
    ALLOCATE(IMASSIFNUMBER_FULL(YSC%U%NDIM_FULL))
    ALLOCATE(IMASSIFNUMBER_LOC(YSC%U%NSIZE_FULL))
#ifdef SFX_MPI
  IF (LSFX_MPI) THEN
    IF (NPROC>1) THEN
  
      ALLOCATE(IDISPLS(0:NPROC-1))
      ALLOCATE(IDISPLS_INT(0:NPROC-1))
      IDISPLS(0)=0
      IDISPLS_INT(0)=0
      
      !IRANK est le rang du thread associé au 1er point
      IPOS=1
      IRANK=NINDEX(IPOS)
      IDISPLS(IRANK)=0
      IDISPLS_INT(IRANK)=0
      
      ! Attention cette méthode ne marche que si NINDEX est continu (découpage linéaire)
      DO JPROC=1,NPROC-1
        !INEXTRANK est le rang du thread suivant : on décale IPOS du nb de points affectés au thread précedent
        !                                        et on ajoute à IDISPLS(INEXTRANK) l'espace correspondant
        IPOS=IPOS+NSIZE_TASK(IRANK)
        INEXTRANK=NINDEX(IPOS)
        IDISPLS(INEXTRANK)=IDISPLS(IRANK)+NSIZE_TASK(IRANK)*KIND(YSC%U%XZS)/4
        IDISPLS_INT(INEXTRANK)=IDISPLS_INT(IRANK)+NSIZE_TASK(IRANK)*KIND(IMASSIFNUMBER_LOC)/4
        IRANK=INEXTRANK
      END DO

      CALL MPI_ALLGATHERV(YSC%U%XZS,SIZE(YSC%U%XZS)*KIND(YSC%U%XZS)/4,MPI_REAL,ZZS1D_FULL,                                 &
                          NSIZE_TASK(:)*KIND(YSC%U%XZS)/4,IDISPLS,MPI_REAL,NCOMM,INFOMPI)
      CALL MPI_ALLGATHERV(YSC%USS%XSSO_DIR,SIZE(YSC%USS%XSSO_DIR)*KIND(YSC%USS%XSSO_DIR)/4,MPI_REAL,ZSSO_DIR_FULL,         &
                          NSIZE_TASK(:)*KIND(YSC%USS%XSSO_DIR)/4,IDISPLS,MPI_REAL,NCOMM,INFOMPI)
      CALL MPI_ALLGATHERV(YSC%USS%XSSO_SLOPE,SIZE(YSC%USS%XSSO_SLOPE)*KIND(YSC%USS%XSSO_SLOPE)/4,MPI_REAL,ZSSO_SLOPE_FULL, &
                          NSIZE_TASK(:)*KIND(YSC%USS%XSSO_SLOPE)/4,IDISPLS,MPI_REAL,NCOMM,INFOMPI)
    
    ELSE
      ZZS1D_FULL=YSC%U%XZS
      ZSSO_DIR_FULL=YSC%USS%XSSO_DIR
      ZSSO_SLOPE_FULL=YSC%USS%XSSO_SLOPE
    ENDIF
  ENDIF
#else
    ZZS1D_FULL=YSC%U%XZS
    ZSSO_DIR_FULL=YSC%USS%XSSO_DIR
    ZSSO_SLOPE_FULL=YSC%USS%XSSO_SLOPE
#endif
    
    IF (NRANK==NPIO) THEN
      CALL OL_FIND_FILE_READ('massif_number',IFILE_ID,OOPTIONAL=.TRUE.)
      GMASSIF = (IFILE_ID/=0)
    ENDIF
    
#ifdef SFX_MPI
    IF (LSFX_MPI) THEN
      IF (NPROC>1) THEN
        CALL MPI_BCAST(GMASSIF,1,MPI_LOGICAL,NPIO,NCOMM,INFOMPI)
      ENDIF
    ENDIF
#endif

    IF (GMASSIF) THEN
        CALL READ_SURF(&
                'OFFLIN','massif_number',IMASSIFNUMBER_LOC,JRET)
        IMASSIFNUMBER_FULL = IMASSIFNUMBER_LOC
#ifdef SFX_MPI
      IF (LSFX_MPI) THEN
        IF (NPROC>1) THEN
          CALL MPI_ALLGATHERV(IMASSIFNUMBER_LOC,SIZE(IMASSIFNUMBER_LOC)*KIND(IMASSIFNUMBER_LOC)/4,MPI_INTEGER,IMASSIFNUMBER_FULL, &
                          NSIZE_TASK(:)*KIND(IMASSIFNUMBER_LOC)/4,IDISPLS_INT,MPI_INTEGER,NCOMM,INFOMPI)                
        ENDIF
      ENDIF
#endif
    ENDIF
    
ELSE
    ALLOCATE(ZZS1D_FULL(0))
    ALLOCATE(ZSSO_DIR_FULL(0))
    ALLOCATE(ZSSO_SLOPE_FULL(0))
    ALLOCATE(IMASSIFNUMBER_FULL(0))
    ALLOCATE(IMASSIFNUMBER_LOC(0))
ENDIF

IF (NRANK==NPIO) THEN
  !       
  CALL INIT_OUTFN_SURF_ATM_n(YSC%DUO, YSC%UG, YSC%U, YSC%CHE, YSC%CHU, YSC%SV, YSC%DUO%CSELECT, "NC    ",ILUOUT)
  !
  IF (YSC%U%NDIM_NATURE>0) THEN
    IF (YSC%U%CNATURE=='ISBA  '.OR.YSC%U%CNATURE=='TSZ0  ') THEN 
      IF (LWRITE_TOPO) THEN
        CALL INIT_OUTFN_ISBA_n(YSC%IM, YSC%UG, YSC%U, YSC%DUO%CSELECT, &
                              YSC%DUO%LSNOWDIMNC, "NC    ",ILUOUT,    &
                              ZZS1D_FULL, ZSSO_DIR_FULL, ZSSO_SLOPE_FULL, &
                              IMASSIFNUMBER_FULL)
      ELSE
        CALL INIT_OUTFN_ISBA_n(YSC%IM, YSC%UG, YSC%U, YSC%DUO%CSELECT, &
                              YSC%DUO%LSNOWDIMNC, "NC    ",ILUOUT)
      ENDIF                                
		ENDIF
  ENDIF
  !
  IF (YSC%U%NDIM_SEA>0) THEN
    IF (YSC%U%CSEA=='SEAFLX') THEN 
      CALL INIT_OUTFN_SEA_n(YSC%SM, YSC%UG, YSC%U, YSC%DUO%CSELECT, "NC    ",ILUOUT)
    ENDIF
  ENDIF
  !
  IF (YSC%U%NDIM_WATER>0) THEN
    IF (YSC%U%CWATER=='WATFLX') CALL INIT_OUTFN_WATER_n(YSC%WM, YSC%UG, YSC%U, YSC%DUO%CSELECT, "NC    ",ILUOUT)
    IF (YSC%U%CWATER=='FLAKE ') CALL INIT_OUTFN_FLAKE_n(YSC%FM, YSC%UG, YSC%U, YSC%DUO%CSELECT, "NC    ",ILUOUT)
  ENDIF
  !
  IF (YSC%U%NDIM_TOWN>0) THEN
    IF (YSC%U%CTOWN=='TEB   ') THEN 
      CALL INIT_OUTFN_TEB_n(YSC%TM, YSC%GDM, YSC%GRM, YSC%UG, YSC%U, YSC%DUO%CSELECT, "NC    ",ILUOUT)
    ENDIF
  ENDIF
  !
ENDIF

IF (LWRITE_TOPO) THEN
  DEALLOCATE(ZZS1D_FULL)
  DEALLOCATE(ZSSO_DIR_FULL)
  DEALLOCATE(ZSSO_SLOPE_FULL)
  DEALLOCATE(IMASSIFNUMBER_FULL)
  DEALLOCATE(IMASSIFNUMBER_LOC)
#ifdef SFX_MPI
  IF (LSFX_MPI) THEN
    IF (NPROC>1) THEN
      DEALLOCATE(IDISPLS)
      DEALLOCATE(IDISPLS_INT)    
    ENDIF
  ENDIF
#endif
ENDIF
!
!------------------------------------------------------------------------------
IF (LHOOK) CALL DR_HOOK('INIT_OUTPUT_OL_N',1,ZHOOK_HANDLE)
!------------------------------------------------------------------------------
!
END SUBROUTINE INIT_OUTPUT_OL_n
