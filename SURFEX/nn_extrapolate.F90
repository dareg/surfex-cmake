!@no_insert_drhook
MODULE NN_EXTRAPOLATE
! This module provides the fast in-place nearest neighbour interpolation/extrapolation.
! To speed-up the nearest neighbour query kD-tree is used.
!
! AUTHOR
! Y. Batrak
!
! MODIFICATIONS
! Original  08/2014
  USE YOMHOOK,    ONLY: LHOOK, DR_HOOK, JPHOOK
  IMPLICIT NONE
  PRIVATE
  REAL, PARAMETER :: XINF = 1.E+21

  PUBLIC :: NEAREST_NEIGHBOUR_EXTRAPOLATE, &
            NEAREST_NEIGHBOUR_QUERY, &
            DISTANCE_QUERY
  ! This type must have 16-byte size.
  TYPE :: INDEXED
      SEQUENCE
      REAL   (KIND=KIND(0.0D0)) :: VALUE
      INTEGER(KIND=KIND(0.0D0)) :: IDX
  END TYPE

  TYPE :: T_SINCOS
      SEQUENCE
      REAL :: SIN
      REAL :: COS
      REAL :: VAL
  END TYPE T_SINCOS

  TYPE :: KD_NODE
      SEQUENCE
      LOGICAL        :: G_IS_X_SECTION
      INTEGER        :: I_VAL
      TYPE(T_SINCOS) :: LON, LAT

      TYPE(KD_NODE), POINTER :: LEFT   => NULL(), &
                                RIGHT  => NULL(), &
                                PARENT => NULL()
  END TYPE

  TYPE :: NN_BUFFER
      SEQUENCE
      INTEGER :: BUFFER_SIZE
      REAL :: FURTHEST_DIST
      TYPE(INDEXED), ALLOCATABLE :: BUFFER(:)
  END TYPE

  INTERFACE NEAREST_NEIGHBOUR_QUERY
      MODULE PROCEDURE :: NEAREST_NEIGHBOUR_QUERY, &
                          NEAREST_NEIGHBOUR_POINT_QUERY
  END INTERFACE

CONTAINS
  PURE FUNCTION SINCOS(P_X) RESULT(RES)
    IMPLICIT NONE
    REAL, INTENT(IN) :: P_X
    TYPE(T_SINCOS) :: RES

    INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(15,307)
    REAL, PARAMETER :: XPI = 2.0_DBL*ASIN(1.0_DBL)

    RES%SIN = SIN(P_X*XPI/180._DBL)
    RES%COS = COS(P_X*XPI/180._DBL)
    RES%VAL = P_X
  END FUNCTION SINCOS

  SUBROUTINE PUSH_TO_BUFFER(TP_BUFFER, TP_NODE, ZDIST)
    IMPLICIT NONE
    TYPE(NN_BUFFER), INTENT(IN OUT) :: TP_BUFFER
    TYPE(KD_NODE), INTENT(IN), POINTER :: TP_NODE
    REAL, INTENT(IN) :: ZDIST

    IF(TP_BUFFER%BUFFER_SIZE == 1) THEN
      TP_BUFFER%BUFFER(1) = INDEXED(VALUE=ZDIST, IDX=TP_NODE%I_VAL)
      TP_BUFFER%FURTHEST_DIST = ZDIST
    ELSE
      TP_BUFFER%BUFFER(TP_BUFFER%BUFFER_SIZE + 1) = INDEXED(VALUE=ZDIST, IDX=TP_NODE%I_VAL)

      CALL QSORT(TP_BUFFER%BUFFER)

      IF(TP_BUFFER%BUFFER(TP_BUFFER%BUFFER_SIZE)%VALUE == XINF) THEN
        TP_BUFFER%FURTHEST_DIST = XINF
      ELSE
        TP_BUFFER%FURTHEST_DIST = TP_BUFFER%BUFFER(TP_BUFFER%BUFFER_SIZE)%VALUE
      ENDIF
    ENDIF
  END SUBROUTINE PUSH_TO_BUFFER

  PURE FUNCTION DISTANCE_QUERY(PLON1, PLAT1, PLON2, PLAT2) RESULT(DIST)
    IMPLICIT NONE
    REAL, INTENT(IN) :: PLON1, PLAT1, PLON2, PLAT2
    REAL :: DIST

    DIST = DISTANCE(SINCOS(PLON1), SINCOS(PLAT1), SINCOS(PLON2), SINCOS(PLAT2))
  END FUNCTION DISTANCE_QUERY

  SUBROUTINE NEAREST_NEIGHBOUR_POINT_QUERY(P_LONS_IN, P_LATS_IN, &
      P_LON_OUT, P_LAT_OUT, O_INPUT_MASK, K_NUMN, K_INDEX, P_DIST, O_CLEANUP, O_REINIT)
    IMPLICIT NONE

    REAL, INTENT(IN) :: P_LONS_IN(:)
    REAL, INTENT(IN), DIMENSION(SIZE(P_LONS_IN)) :: &
        P_LATS_IN
    LOGICAL, INTENT(IN), DIMENSION(SIZE(P_LONS_IN)), OPTIONAL :: O_INPUT_MASK !< Use only .TRUE. points
    REAL, INTENT(IN) :: P_LON_OUT
    REAL, INTENT(IN) :: P_LAT_OUT
    INTEGER, INTENT(IN) :: K_NUMN !< Lookup for N nearest points
    REAL, INTENT(OUT), OPTIONAL, DIMENSION(K_NUMN) :: P_DIST
    INTEGER, INTENT(OUT), OPTIONAL, DIMENSION(K_NUMN) :: K_INDEX
    LOGICAL, INTENT(IN), OPTIONAL :: O_CLEANUP, O_REINIT

    REAL, DIMENSION(K_NUMN) :: Z_DIST
    INTEGER, DIMENSION(K_NUMN) :: I_INDEX

    INTEGER, DIMENSION(SIZE(P_LONS_IN)) :: INPUT_INDICES

    INTEGER, ALLOCATABLE :: INPUT_MASK(:)
    LOGICAL :: GINPUT_MASK(SIZE(P_LONS_IN))

    INTEGER :: JI_MASK, JI
    TYPE(NN_BUFFER) :: BUFFER

    LOGICAL, SAVE :: IS_FIRST_QUERY = .TRUE.
    TYPE(KD_NODE), SAVE, POINTER :: TZ_ROOT
    INTEGER, SAVE :: INPUT_SIZE

    IF(PRESENT(O_CLEANUP)) THEN
      IF(O_CLEANUP) CALL RELEASE_KD_TREE(TZ_ROOT)
      RETURN
    END IF

    IF(PRESENT(O_REINIT)) IS_FIRST_QUERY = O_REINIT
    IF(IS_FIRST_QUERY) THEN
      IS_FIRST_QUERY = .FALSE.
      NULLIFY(TZ_ROOT)

      IF(PRESENT(O_INPUT_MASK)) THEN
          GINPUT_MASK = O_INPUT_MASK
      ELSE
          GINPUT_MASK = .TRUE.
      END IF

      INPUT_SIZE = SIZE(P_LONS_IN)

      ALLOCATE(INPUT_MASK(COUNT(GINPUT_MASK)))
      JI_MASK = 1
      DO JI=1,INPUT_SIZE
        IF(GINPUT_MASK(JI)) THEN
          INPUT_MASK(JI_MASK) = JI
          JI_MASK = JI_MASK + 1
        END IF
      END DO
      INPUT_INDICES(:) = [(JI,JI=1,INPUT_SIZE)]
      CALL BUILD_KD_TREE(P_LONS_IN(INPUT_MASK), P_LATS_IN(INPUT_MASK), &
          INPUT_INDICES(INPUT_MASK), .TRUE., NULL(TZ_ROOT), TZ_ROOT)

      DEALLOCATE(INPUT_MASK)
    END IF
    IF(INPUT_SIZE == 0) THEN
      WRITE(*,*) 'Nothing to extrapolate...'
      K_INDEX = 0
      P_DIST = -1.
      RETURN
    END IF

    BUFFER%BUFFER_SIZE = K_NUMN
    ALLOCATE(BUFFER%BUFFER(K_NUMN + 1))
    BUFFER%FURTHEST_DIST = XINF

    BUFFER%BUFFER(:)%IDX = 0
    BUFFER%BUFFER(:)%VALUE = XINF

    CALL NEAREST_NEIGHBOUR_N( TZ_ROOT, SINCOS(P_LON_OUT), SINCOS(P_LAT_OUT), BUFFER )
    I_INDEX = BUFFER%BUFFER(:K_NUMN)%IDX
    Z_DIST = BUFFER%BUFFER(:K_NUMN)%VALUE

    WHERE(Z_DIST == XINF)
      Z_DIST = 0.
      I_INDEX = 0
    ENDWHERE

    DEALLOCATE(BUFFER%BUFFER)

    IF(PRESENT(K_INDEX)) K_INDEX = I_INDEX
    IF(PRESENT(P_DIST)) P_DIST = Z_DIST

  END SUBROUTINE NEAREST_NEIGHBOUR_POINT_QUERY

  SUBROUTINE NEAREST_NEIGHBOUR_QUERY(P_LONS_IN, P_LATS_IN, P_LONS_OUT, P_LATS_OUT, O_INPUT_MASK, K_INDEX, P_DIST)
    IMPLICIT NONE

    REAL, INTENT(IN) :: P_LONS_IN(:)
    REAL, INTENT(IN), DIMENSION(SIZE(P_LONS_IN)) :: &
        P_LATS_IN
    LOGICAL, INTENT(IN), DIMENSION(SIZE(P_LONS_IN)), OPTIONAL :: O_INPUT_MASK !< Use only .TRUE. points
    REAL, INTENT(IN) :: P_LONS_OUT(:)
    REAL, INTENT(IN), DIMENSION(SIZE(P_LONS_OUT)) :: P_LATS_OUT
    REAL, INTENT(OUT), OPTIONAL, DIMENSION(SIZE(P_LONS_OUT)) :: P_DIST
    INTEGER, INTENT(OUT), OPTIONAL, DIMENSION(SIZE(P_LONS_OUT)) :: K_INDEX

    REAL, DIMENSION(SIZE(P_LONS_OUT)) :: Z_DIST
    INTEGER, DIMENSION(SIZE(P_LONS_OUT)) :: I_INDEX

    INTEGER, DIMENSION(SIZE(P_LONS_IN)) :: INPUT_INDICES

    INTEGER, ALLOCATABLE :: INPUT_MASK(:)
    LOGICAL :: GINPUT_MASK(SIZE(P_LONS_IN))

    TYPE(KD_NODE), POINTER :: TZ_ROOT, TZ_LEAF
    INTEGER :: INPUT_SIZE, NUM_EXTR, JI_MASK, JI

    REAL :: Z_LAT, Z_LON
    TYPE(NN_BUFFER) :: BUFFER

    INTEGER(KIND=8) :: JSTART, JRATE, JMAX, JTREE, JEXTR, JRELEASE
    REAL :: ZRATE

    NULLIFY(TZ_ROOT, TZ_LEAF)

    CALL SYSTEM_CLOCK( COUNT=JSTART, COUNT_RATE=JRATE, COUNT_MAX=JMAX )
    ZRATE = REAL( JRATE )

    IF(PRESENT(O_INPUT_MASK)) THEN
        GINPUT_MASK = O_INPUT_MASK
    ELSE
        GINPUT_MASK = .TRUE.
    END IF

    NUM_EXTR = SIZE(P_LONS_OUT)
    INPUT_SIZE = SIZE(P_LONS_IN)

    ALLOCATE(INPUT_MASK(COUNT(GINPUT_MASK)))
    JI_MASK = 0
    DO JI=1,INPUT_SIZE
      IF(GINPUT_MASK(JI)) THEN
        JI_MASK = JI_MASK + 1
        INPUT_MASK(JI_MASK) = JI
      END IF
    END DO
    IF(JI_MASK == 0 .OR. NUM_EXTR == 0) THEN
      WRITE(*,*) 'Nothing to extrapolate...'
      RETURN
    ELSE
      WRITE(*,*) 'Extrapolation of ', NUM_EXTR, ' points...'
    END IF

    INPUT_INDICES(:) = [(JI,JI=1,INPUT_SIZE)]
    CALL BUILD_KD_TREE(P_LONS_IN(INPUT_MASK), P_LATS_IN(INPUT_MASK), INPUT_INDICES(INPUT_MASK), .TRUE., NULL(TZ_ROOT), TZ_ROOT)
    CALL SYSTEM_CLOCK( COUNT=JTREE )

    BUFFER%BUFFER_SIZE = 1
    ALLOCATE(BUFFER%BUFFER(1))
    BUFFER%FURTHEST_DIST = XINF

    DO JI = 1, NUM_EXTR
      BUFFER%BUFFER(:)%IDX = 0
      BUFFER%BUFFER(:)%VALUE = XINF
      BUFFER%FURTHEST_DIST = XINF

      Z_LAT = P_LATS_OUT(JI)
      Z_LON = P_LONS_OUT(JI)
      CALL NEAREST_NEIGHBOUR_N( TZ_ROOT, SINCOS(Z_LON), SINCOS(Z_LAT), BUFFER )
      I_INDEX(JI) = BUFFER%BUFFER(1)%IDX
      Z_DIST(JI) = BUFFER%BUFFER(1)%VALUE
    END DO
    CALL SYSTEM_CLOCK( COUNT=JEXTR )
    DEALLOCATE(INPUT_MASK, BUFFER%BUFFER)
    CALL RELEASE_KD_TREE(TZ_ROOT)
    CALL SYSTEM_CLOCK( COUNT=JRELEASE )

    IF( JRATE /= 0 .AND. JMAX /= 0 ) THEN
      WRITE(*,'(A6, F8.2, A, F8.2, A, F8.2, A, F8.2)') &
             'ETIME:', (JTREE    - JSTART)/ZRATE, '/', &
                       (JEXTR    - JTREE )/ZRATE, '/', &
                       (JRELEASE - JEXTR )/ZRATE, ':', &
                       (JRELEASE - JSTART)/ZRATE
    ELSE
        WRITE(*,*) 'Timer problem...'
    END IF

    IF(PRESENT(K_INDEX)) K_INDEX = I_INDEX
    IF(PRESENT(P_DIST)) P_DIST = Z_DIST

  END SUBROUTINE NEAREST_NEIGHBOUR_QUERY

  SUBROUTINE NEAREST_NEIGHBOUR_EXTRAPOLATE( P_FLD, P_LONS, P_LATS, O_MASK, O_EXT_MASK )
    IMPLICIT NONE

    REAL,    INTENT( IN OUT )                         :: P_FLD(:) !< Field which should be filled
    REAL,    INTENT( IN     ), DIMENSION(SIZE(P_FLD)) :: &
        P_LONS,     & !< Longitudes vector
        P_LATS        !< Latitudes vector
    LOGICAL, INTENT( IN     ) :: O_MASK(SIZE(P_FLD)) !< Mask, .TRUE. values indicate data, .FALSE. -- cells, which should be extrapolated
    LOGICAL, INTENT( IN     ), OPTIONAL :: O_EXT_MASK(SIZE(P_FLD)) !< Explicit extrapolation mask, if we want to fill only some of undefined cells

    LOGICAL :: G_EXT_MASK(SIZE(P_FLD))

    INTEGER, ALLOCATABLE   :: I_MASK(:), I_EXT_MASK(:), I_NN_IDX(:)
    REAL, ALLOCATABLE   :: Z_MASKED_FLD(:)

    INTEGER :: JI, JI_MASK, JI_EXT_MASK
    INTEGER :: IDATA_SIZE, IEXT_SIZE

    REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

    G_EXT_MASK = .NOT. O_MASK
    IF(PRESENT(O_EXT_MASK)) G_EXT_MASK = O_EXT_MASK

    IDATA_SIZE = COUNT(O_MASK)
    IEXT_SIZE = COUNT(G_EXT_MASK)

    ALLOCATE( I_MASK(IDATA_SIZE), I_EXT_MASK(IEXT_SIZE) )
    ALLOCATE( Z_MASKED_FLD(IDATA_SIZE))
    ALLOCATE( I_NN_IDX(IEXT_SIZE))

    ! Construct index vectors for data and extrapolation points.
    JI_MASK     = 1
    JI_EXT_MASK = 1
    DO JI = 1, SIZE(P_FLD)
      IF(O_MASK(JI)) THEN
        I_MASK(JI_MASK) = JI
        JI_MASK = JI_MASK + 1
      END IF
      IF(G_EXT_MASK(JI)) THEN
        I_EXT_MASK(JI_EXT_MASK) = JI
        JI_EXT_MASK = JI_EXT_MASK + 1
      END IF
    END DO

    CALL NEAREST_NEIGHBOUR_QUERY(P_LONS(I_MASK), P_LATS(I_MASK), &
      P_LONS(I_EXT_MASK), P_LATS(I_EXT_MASK), K_INDEX=I_NN_IDX)
    Z_MASKED_FLD(:) = P_FLD(I_MASK)
    P_FLD(I_EXT_MASK) = Z_MASKED_FLD(I_NN_IDX)

    DEALLOCATE(I_MASK, I_EXT_MASK, I_NN_IDX)
    DEALLOCATE(Z_MASKED_FLD)
  END SUBROUTINE NEAREST_NEIGHBOUR_EXTRAPOLATE

  RECURSIVE SUBROUTINE NEAREST_NEIGHBOUR_N( TP_TREE, P_LON, P_LAT, TP_BUFFER )
    IMPLICIT NONE

    TYPE(KD_NODE), POINTER, INTENT(IN) :: TP_TREE
    TYPE(T_SINCOS),         INTENT(IN) :: P_LON, P_LAT
    TYPE(NN_BUFFER) :: TP_BUFFER

    TYPE(KD_NODE), POINTER :: TZ_CURRENT, TZ_LEAF, TZ_CHILD
    REAL    :: Z_DIST, Z_CURR_BEST
    LOGICAL :: G_CROSS

    REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

    IF(.NOT. ASSOCIATED(TP_TREE)) RETURN

    ! For first guess we use leaf, which contains givent point
    CALL FIND_NEAR_LEAF( TP_TREE, P_LON%VAL, P_LAT%VAL, TZ_LEAF )

    TZ_CURRENT => TZ_LEAF
    TZ_CHILD => TZ_LEAF

    DO WHILE( ASSOCIATED(TZ_CURRENT) )
      Z_DIST = DISTANCE( P_LON, P_LAT, TZ_CURRENT%LON, TZ_CURRENT%LAT )
      IF( Z_DIST < TP_BUFFER%FURTHEST_DIST ) THEN
        CALL PUSH_TO_BUFFER(TP_BUFFER, TZ_CURRENT, Z_DIST)
      END IF

      ! Check intersection betweent best estimate circle and splitting axis.
      IF( TZ_CURRENT%G_IS_X_SECTION ) THEN
        G_CROSS = DISTANCE( P_LON, P_LAT, TZ_CURRENT%LON, P_LAT) < TP_BUFFER%FURTHEST_DIST
      ELSE
        G_CROSS = DISTANCE( P_LON, P_LAT, P_LON, TZ_CURRENT%LAT) < TP_BUFFER%FURTHEST_DIST
      END IF

      IF(G_CROSS) THEN
        IF( ASSOCIATED(TZ_CURRENT%LEFT, TARGET=TZ_CHILD) ) THEN !Previous node was the left branch of the current node
          IF(ASSOCIATED(TZ_CURRENT%RIGHT)) CALL NEAREST_NEIGHBOUR_N(TZ_CURRENT%RIGHT, P_LON, P_LAT, TP_BUFFER)
        ELSE ! Previous node was the right branch
          IF(ASSOCIATED(TZ_CURRENT%LEFT )) CALL NEAREST_NEIGHBOUR_N(TZ_CURRENT%LEFT,  P_LON, P_LAT, TP_BUFFER)
        END IF
      END IF

      TZ_CHILD => TZ_CURRENT
      IF(ASSOCIATED(TZ_CURRENT, TARGET=TP_TREE)) THEN
        TZ_CURRENT => NULL()
      ELSE
        TZ_CURRENT => TZ_CURRENT%PARENT
      END IF
    END DO
  END SUBROUTINE NEAREST_NEIGHBOUR_N

  PURE FUNCTION DISTANCE( P_LON1, P_LAT1, P_LON2, P_LAT2 ) RESULT( DST )
    IMPLICIT NONE
    TYPE(T_SINCOS), INTENT( IN ) :: P_LON1, P_LAT1
    TYPE(T_SINCOS), INTENT( IN ) :: P_LON2, P_LAT2
    REAL :: DST

    REAL :: Z_RATIO

    Z_RATIO = P_LAT1%SIN*P_LAT2%SIN + P_LAT1%COS*P_LAT2%COS*(P_LON1%COS*P_LON2%COS + P_LON1%SIN*P_LON2%SIN)

    IF(Z_RATIO > 1) THEN
      DST = 0.
    ELSE
      DST = ACOS(Z_RATIO)*6.378137E+6
    END IF
  END FUNCTION DISTANCE

  ! Find leaf of the tree, where given point lays, through recursive traversal.
  RECURSIVE SUBROUTINE FIND_NEAR_LEAF( TP_TREE, P_LON, P_LAT, TP_LEAF )
    IMPLICIT NONE

    TYPE(KD_NODE), POINTER, INTENT( IN ) :: TP_TREE
    REAL,          INTENT( IN ) :: P_LON, P_LAT
    TYPE(KD_NODE), POINTER      :: TP_LEAF

    REAL(KIND=JPHOOK) :: ZHOOK_HANDLE


    IF( TP_TREE%G_IS_X_SECTION ) THEN
      IF( P_LON < TP_TREE%LON%VAL ) THEN
        IF ( .NOT. ASSOCIATED( TP_TREE%LEFT  ) ) THEN
          TP_LEAF => TP_TREE
        ELSE
          CALL FIND_NEAR_LEAF( TP_TREE%LEFT, P_LON, P_LAT, TP_LEAF )
        END IF
      ELSE
        IF ( .NOT. ASSOCIATED( TP_TREE%RIGHT ) ) THEN
          TP_LEAF => TP_TREE
        ELSE
          CALL FIND_NEAR_LEAF( TP_TREE%RIGHT, P_LON, P_LAT, TP_LEAF )
        END IF
      END IF
    ELSE
      IF( P_LAT < TP_TREE%LAT%VAL ) THEN
        IF ( .NOT. ASSOCIATED( TP_TREE%LEFT  ) ) THEN
          TP_LEAF => TP_TREE
        ELSE
          CALL FIND_NEAR_LEAF( TP_TREE%LEFT, P_LON, P_LAT, TP_LEAF )
        END IF
      ELSE
        IF ( .NOT. ASSOCIATED( TP_TREE%RIGHT ) ) THEN
          TP_LEAF => TP_TREE
        ELSE
          CALL FIND_NEAR_LEAF( TP_TREE%RIGHT, P_LON, P_LAT, TP_LEAF )
        END IF
      END IF
    END IF
  END SUBROUTINE FIND_NEAR_LEAF

  RECURSIVE SUBROUTINE BUILD_KD_TREE( P_LONS, P_LATS, K_IND, O_SPLIT_X, TP_PARENT, TP_TREE )
    IMPLICIT NONE
    REAL, INTENT( IN ) :: P_LONS( :            ), &
                          P_LATS( SIZE(P_LONS) )
    INTEGER, INTENT( IN ) ::   K_IND( SIZE(P_LONS) )
    LOGICAL, INTENT(IN):: O_SPLIT_X
    TYPE(KD_NODE), POINTER, INTENT(IN) :: TP_PARENT
    TYPE(KD_NODE), POINTER    :: TP_TREE

    TYPE(INDEXED)      :: TZ_IDXS  ( SIZE(P_LONS) )

    INTEGER :: I_LEN, I_MED, I_MED_VAL
    INTEGER :: JI

    REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

    IF( LHOOK ) CALL DR_HOOK( 'BUILD_KD_TREE', 0, ZHOOK_HANDLE )

    I_LEN = SIZE( P_LONS )

    IF( .NOT. ASSOCIATED(TP_TREE) ) ALLOCATE(TP_TREE)

    TP_TREE%G_IS_X_SECTION = O_SPLIT_X
    TP_TREE%PARENT => TP_PARENT

    IF( I_LEN == 1 ) THEN
      TP_TREE%LON = SINCOS(P_LONS(1))
      TP_TREE%LAT = SINCOS(P_LATS(1))
      TP_TREE%I_VAL   = K_IND (1)
    ELSE
      TZ_IDXS%IDX = [(JI,JI=1,I_LEN)]
      IF( O_SPLIT_X ) THEN
          TZ_IDXS%VALUE = P_LONS
      ELSE
          TZ_IDXS%VALUE = P_LATS
      END IF
      CALL QSORT( TZ_IDXS ) ! Sort data coordinates along the splitting axis

      I_MED     = (1 + I_LEN)/2
      I_MED_VAL = TZ_IDXS( I_MED  )%IDX ! Select index of the median value

      TP_TREE%LON        = SINCOS(P_LONS( I_MED_VAL ))
      TP_TREE%LAT        = SINCOS(P_LATS( I_MED_VAL ))
      TP_TREE%I_VAL      = K_IND ( I_MED_VAL )

      IF( I_MED > 1 ) THEN
        CALL BUILD_KD_TREE( &
          P_LONS( TZ_IDXS( 1:I_MED - 1 )%IDX ),   &
          P_LATS( TZ_IDXS( 1:I_MED - 1 )%IDX ),   &
          K_IND ( TZ_IDXS( 1:I_MED - 1 )%IDX ),   &
          .NOT. O_SPLIT_X,                        &
          TP_TREE,                                &
          TP_TREE%LEFT )
      ENDIF
      CALL BUILD_KD_TREE( &
        P_LONS( TZ_IDXS( I_MED + 1:I_LEN )%IDX ), &
        P_LATS( TZ_IDXS( I_MED + 1:I_LEN )%IDX ), &
        K_IND ( TZ_IDXS( I_MED + 1:I_LEN )%IDX ), &
        .NOT. O_SPLIT_X,                          &
        TP_TREE,                                  &
        TP_TREE%RIGHT )
    END IF

    IF( LHOOK ) CALL DR_HOOK( 'BUILD_KD_TREE', 1, ZHOOK_HANDLE )
  END SUBROUTINE BUILD_KD_TREE

  RECURSIVE SUBROUTINE RELEASE_KD_TREE( TP_TREE )
    IMPLICIT NONE

    TYPE( KD_NODE ), POINTER :: TP_TREE

    REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

    IF( LHOOK ) CALL DR_HOOK( 'RELEASE_KD_TREE', 0, ZHOOK_HANDLE )

    IF(ASSOCIATED(TP_TREE)) THEN
      IF( ASSOCIATED(TP_TREE%LEFT)  ) THEN
        CALL RELEASE_KD_TREE(TP_TREE%LEFT)
        DEALLOCATE(TP_TREE%LEFT)
      END IF
      IF( ASSOCIATED(TP_TREE%RIGHT) ) THEN
        CALL RELEASE_KD_TREE(TP_TREE%RIGHT)
        DEALLOCATE(TP_TREE%RIGHT)
      END IF
    END IF

    IF( LHOOK ) CALL DR_HOOK( 'RELEASE_KD_TREE', 1, ZHOOK_HANDLE )
  END SUBROUTINE RELEASE_KD_TREE

  SUBROUTINE QSORT( IDXS )
    USE, INTRINSIC :: ISO_C_BINDING
    IMPLICIT NONE

    TYPE(INDEXED), INTENT( IN OUT ), TARGET :: IDXS(:)

    INTEGER(C_SIZE_T) :: ELEM_COUNT
    INTEGER(C_SIZE_T) :: ELEM_SIZE

    REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

    INTERFACE
      SUBROUTINE QSORT_C(ARRAY,ELEM_COUNT,ELEM_SIZE,COMPARE) BIND(C,NAME="qsort")
        IMPORT
        TYPE   (C_PTR   ), VALUE :: ARRAY
        INTEGER(C_SIZE_T), VALUE :: ELEM_COUNT
        INTEGER(C_SIZE_T), VALUE :: ELEM_SIZE
        TYPE   (C_FUNPTR), VALUE :: COMPARE !int(*compare)(const void *, const void *)
      END SUBROUTINE QSORT_C !standard C library qsort
    END INTERFACE

    IF( LHOOK ) CALL DR_HOOK( 'QSORT', 0, ZHOOK_HANDLE )

    ELEM_COUNT = SIZE( IDXS )
    ELEM_SIZE  = 16

    CALL QSORT_C( C_LOC(IDXS(1)), ELEM_COUNT, ELEM_SIZE, C_FUNLOC(COMPAR) )

    IF( LHOOK ) CALL DR_HOOK( 'QSORT', 1, ZHOOK_HANDLE )
  END SUBROUTINE QSORT

    ! Comaparator for standard C library qsort
  FUNCTION COMPAR( A, B ) RESULT(RES) BIND(C)
    USE, INTRINSIC :: ISO_C_BINDING
    IMPLICIT NONE

    TYPE   (C_PTR),VALUE :: A, B
    INTEGER(C_INT)       :: RES

    TYPE(INDEXED), POINTER :: AF, BF

    CALL C_F_POINTER( A, AF )
    CALL C_F_POINTER( B, BF )

    IF ( AF%VALUE <  BF%VALUE ) RES = -1
    IF ( AF%VALUE == BF%VALUE ) RES =  0
    IF ( AF%VALUE >  BF%VALUE ) RES =  1

  END FUNCTION COMPAR
END MODULE NN_EXTRAPOLATE
